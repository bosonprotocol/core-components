enum MetadataType {
  BASE
  PRODUCT_V1
}

interface MetadataInterface {
  "<OFFER_ID>-metadata"
  id: ID!
  name: String
  description: String
  "Arbitrary URL which is linked to metadata"
  externalUrl: String
  "JSON schema URL"
  schemaUrl: String
  "Enum"
  type: MetadataType!
  "Reference to related Offer entity"
  offer: Offer!
  "Reference to related Seller entity"
  seller: Seller!
}

type BaseMetadataEntity implements MetadataInterface @entity {
  id: ID!
  name: String
  description: String
  externalUrl: String
  schemaUrl: String
  type: MetadataType! # MetadataType.BASE
  offer: Offer!
  seller: Seller!
}

type ProductV1MetadataEntity implements MetadataInterface @entity {
  id: ID!
  name: String
  description: String
  externalUrl: String
  schemaUrl: String
  type: MetadataType! # MetadataType.PRODUCT
  offer: Offer!
  seller: Seller!
  """
  ProductV1MetadataEntity specific fields
  """
  images: [String!]
  tags: [String!]
  brandName: String
}

"""
Offer
"""
type Offer @entity {
  id: ID!
  createdAt: BigInt!
  price: BigInt!
  sellerDeposit: BigInt!
  buyerCancelPenalty: BigInt!
  quantityAvailable: BigInt!
  validFromDate: BigInt!
  validUntilDate: BigInt!
  redeemableFromDate: BigInt!
  fulfillmentPeriodDuration: BigInt!
  voucherValidDuration: BigInt!
  metadataUri: String!
  offerChecksum: String!
  voided: Boolean!
  sellerId: BigInt!
  seller: Seller!
  exchangeToken: ExchangeToken!
  metadata: MetadataInterface
  voidedAt: BigInt
}

"""
Seller
"""
type Seller @entity {
  id: ID! # Offer.sellerId
  offers: [Offer!]! @derivedFrom(field: "seller")
  operator: Bytes!
  admin: Bytes!
  clerk: Bytes!
  treasury: Bytes!
  active: Boolean!
}

type ExchangeToken @entity {
  id: ID!
  address: Bytes!
  offers: [Offer!]! @derivedFrom(field: "exchangeToken")
  decimals: BigInt!
  symbol: String!
  name: String!
  # TODO: add more fields
}
