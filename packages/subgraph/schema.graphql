enum MetadataType {
  BASE
  PRODUCT_V1
}

interface MetadataInterface {
  "<OFFER_ID>-metadata"
  id: ID!
  name: String
  description: String
  "Arbitrary URL which is linked to metadata"
  externalUrl: String
  "JSON schema URL"
  schemaUrl: String
  "Enum"
  type: MetadataType!
  "Reference to related Offer entity"
  offer: Offer!
  "Reference to related Seller entity"
  seller: Seller!
  "Reference to related ExchangeToken entity"
  exchangeToken: ExchangeToken!
  """
  Enriched fields from offer entity to allow nested query workaround
  """
  createdAt: BigInt!
  voided: Boolean!
  validFromDate: BigInt!
  validUntilDate: BigInt!
}

type BaseMetadataEntity implements MetadataInterface @entity {
  id: ID!
  name: String
  description: String
  externalUrl: String
  schemaUrl: String
  type: MetadataType! # MetadataType.BASE
  offer: Offer!
  seller: Seller!
  exchangeToken: ExchangeToken!
  createdAt: BigInt!
  voided: Boolean!
  validFromDate: BigInt!
  validUntilDate: BigInt!
}

type ProductV1MetadataEntity implements MetadataInterface @entity {
  id: ID!
  name: String
  description: String
  externalUrl: String
  schemaUrl: String
  type: MetadataType! # MetadataType.PRODUCT
  offer: Offer!
  seller: Seller!
  exchangeToken: ExchangeToken!
  createdAt: BigInt!
  voided: Boolean!
  validFromDate: BigInt!
  validUntilDate: BigInt!
  """
  ProductV1MetadataEntity specific fields
  """
  images: [String!]
  tags: [String!]
  brandName: String
  brand: ProductV1Brand!
}

type ProductV1Brand @entity {
  id: ID!
  name: String!
  products: [ProductV1MetadataEntity!]! @derivedFrom(field: "brand")
}

"""
Offer
"""
type Offer @entity {
  id: ID!
  createdAt: BigInt!
  price: BigInt!
  sellerDeposit: BigInt!
  buyerCancelPenalty: BigInt!
  quantityInitial: BigInt!
  quantityAvailable: BigInt!
  validFromDate: BigInt!
  validUntilDate: BigInt!
  redeemableFromDate: BigInt!
  fulfillmentPeriodDuration: BigInt!
  voucherValidDuration: BigInt!
  metadataUri: String!
  offerChecksum: String!
  voided: Boolean!
  sellerId: BigInt!
  seller: Seller!
  exchangeToken: ExchangeToken!
  metadata: MetadataInterface
  voidedAt: BigInt
  exchanges: [Exchange!]! @derivedFrom(field: "offer")
}

"""
Exchange and Voucher
"""
enum ExchangeState {
  COMMITTED
  REVOKED
  CANCELLED
  REDEEMED
  COMPLETED
}

type Exchange @entity {
  id: ID!
  offer: Offer!
  buyer: Buyer!
  seller: Seller
  disputed: Boolean!
  state: ExchangeState!
  committedDate: BigInt!
  finalizedDate: BigInt
  validUntilDate: BigInt
  redeemedDate: BigInt
  expired: Boolean!
}

"""
Accounts
"""
type Seller @entity {
  id: ID! # Offer.sellerId
  sellerId: BigInt! # Allows sorting numerically by id
  offers: [Offer!]! @derivedFrom(field: "seller")
  exchanges: [Exchange!]! @derivedFrom(field: "seller")
  operator: Bytes!
  admin: Bytes!
  clerk: Bytes!
  treasury: Bytes!
  active: Boolean!
}

type Buyer @entity {
  id: ID!
  exchanges: [Exchange!]! @derivedFrom(field: "buyer")
  wallet: Bytes!
  active: Boolean!
}

"""
Tokens
"""
type ExchangeToken @entity {
  id: ID!
  address: Bytes!
  offers: [Offer!]! @derivedFrom(field: "exchangeToken")
  decimals: BigInt!
  symbol: String!
  name: String!
  # TODO: add more fields
}
